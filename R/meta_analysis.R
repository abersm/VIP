#' Run meta-analysis using counts from 2 x 2 contingency table
#'
#' @noRd
meta_analyze_2x2_counts <- function(
    df,
    tx1_outcome1 = "n_vaxed_with_outcome",
    tx2_outcome1 = "n_unvaxed_with_outcome",
    tx1_outcome2 = "n_vaxed_without_outcome",
    tx2_outcome2 = "n_unvaxed_without_outcome",
    label = NULL,
    measure = "OR",
    method = "DL",
    ...) {
  out <- metafor::escalc(
    ai = .subset2(df, tx1_outcome1),
    bi = .subset2(df, tx2_outcome1),
    ci = .subset2(df, tx1_outcome2),
    di = .subset2(df, tx2_outcome2),
    measure = measure,
    append = TRUE
  )
  df$ES <- out$yi
  df$SV <- out$vi
  label <- label %||% ""
  df$y_axis_label <- if (length(label) == 1L) {
    .subset2(df, label) %||% label
  } else {
    label
  }
  metafor::rma(df$ES, df$SV, data = df, slab = df$y_axis_label, method = method, method.random.ci = "classic", ...)
}

#' Run meta-analysis using counts from 2 x 2 contingency table - version 2
#'
#' @noRd
meta_analyze_2x2_counts_v2 <- function(
  df,
  tx1_outcome1 = "n_vaxed_with_outcome",
  tx2_outcome1 = "n_unvaxed_with_outcome",
  tx1_outcome2 = "n_vaxed_without_outcome",
  tx2_outcome2 = "n_unvaxed_without_outcome",
  tx1_total = "n_vaxed",
  tx2_total = "n_unvaxed",
  label = NULL,
  measure = "OR",
  method = "DL",
  ...) {
  if (!is.null(label) && is.character(label)) {
    if (length(label) == 1L && !is.null(z <- .subset2(df, label))) {
      label <- z
    }
  }
  out <- meta::metabin(
    event.e = .subset2(df, tx1_outcome1),
    n.e = .subset2(df, tx1_total),
    event.c = .subset2(df, tx2_outcome1),
    n.c = .subset2(df, tx2_total),
    studlab = label,
    method.random.ci = "classic",
    sm = measure,
    method = method
  )
  # I2: out$I2
  # Tau squared: out$tau2
  # P value for heterogeneity: ?out$pval.Q
  # Study labels: out$studlab
  # Rb: out$Rb
  out
}

# VE meta-analysis --------------------------------------------------------

#' Add columns for log odds estimate of VE
#'
#' Converts VE values (crude or adjusted) to OR (or RR), then log transforms this value
#' @param df Data frame
#' @param estimate,lower,upper Column names in `df` that contain crude or adjusted values for VE estimate, lower limit of CI, and upper limit of CI, respectively. Enter each as a length 1 character vector
#' @param new_colnames Either a length 3 character vector of new column names (order must be `estimate`, `lower`, `upper`) or a function that will be applied to `estimate`, `lower`, and `upper` to generate names of columns containing corresponding log odds transformed values in output. Function should accept length 1 character vector as input and return length 1 character vector as output. Default adds "log_odds_" prefix to `estimate`, `lower`, and `upper`
#' @param check_names If `TRUE` (default), new column names generated by `new_colnames` are checked for overlap with `names(df)`. If `FALSE`, this check is not performed
#' @param allow_name_collison If `TRUE` and any columns in `df` have names that overlap with names generated by `new_colnames`, the original columns in `df` will be replaced/overwritten. Default is `FALSE` (error encountered if overlap exists). Only relevant when `check_names = TRUE`
#' @returns Data frame
#' @noRd
.add_ve_log_odds <- function(
    df,
    estimate = "ve_estimate",
    lower = "ve_lower",
    upper = "ve_upper",
    new_colnames = function(x) paste0("log_odds_", x),
    check_names = TRUE,
    allow_name_collison = FALSE) {
  df_names <- names(df)
  idx <- vapply(df, is.numeric, logical(1), USE.NAMES = FALSE)
  cols <- c(estimate, lower, upper)
  idx <- match(cols, df_names[idx], nomatch = 0L) == 0L
  if (any(idx)) {
    stop(sprintf("In '.add_ve_log_odds', the following inputs to %s do not refer to numeric columns in 'df': %s", paste(shQuote(c("estimate", "lower", "upper")[idx]), collapse = "/"), paste(cols[idx], collapse = ", ")))
  }
  if (is.character(new_colnames)) {
    if (length(new_colnames) != 3L) {
      stop("In '.add_ve_log_odds', when 'new_colnames' is a character vector, it must have length 3")
    }
  } else {
    new_colnames <- new_colnames(cols)
  }
  if (check_names && any(new_colnames %in% df_names)) {
    z <- "In '.add_ve_log_odds', 1 or more values generated by input to 'new_colnames' overlaps with 'names(df)'"
    f <- if (allow_name_collison) warning else stop
    f(z)
  }
  df[[new_colnames[1L]]] <- log(1 - .subset2(df, estimate)/100)
  # Swap order/names of lower and upper estimate to account for the fact that lower > upper after transformation
  df[[new_colnames[2L]]] <- log(1 - .subset2(df, upper)/100)
  df[[new_colnames[3L]]] <- log(1 - .subset2(df, lower)/100)
  df
}

#' Perform meta-analysis using log odds ratio
#'
#' @noRd
.meta_analyze_log_ratio <- function(
    df,
    log_ratio_estimate = "log_odds_ve_estimate",
    log_ratio_lower = "log_odds_ve_lower",
    log_ratio_upper = "log_odds_ve_upper",
    study_label = "article",
    study_label_meta = "Meta-analysis",
    effect_measure = c("OR", "RR"),
    method = "DL",
    random_effects = TRUE,
    ...) {
  effect_measure <- match.arg(effect_measure, choices = c("OR", "RR"))
  estimate <- .subset2(df, log_ratio_estimate)
  lower <- .subset2(df, log_ratio_lower)
  upper <- .subset2(df, log_ratio_upper)
  if (is.null(estimate) || is.null(lower) || is.null(upper)) {
    idx <- c(is.null(estimate), is.null(lower), is.null(upper))
    z <- c(log_ratio_estimate, log_ratio_lower, log_ratio_upper)
    stop(sprintf("In 'meta_analysis_ratio', the following inputs to %s do not refer to columns in 'df': %s", paste(shQuote(c("log_ratio_estimate", "log_ratio_lower", "log_ratio_upper")[idx]), collapse = "/"), paste(z[idx], collapse = ", ")))
  }
  study_label <- study_label %||% ".study_label"
  label <- .subset2(df, study_label)
  meta <- meta::metagen(
    TE = estimate,
    lower = lower,
    upper = upper,
    studlab = label,
    sm = effect_measure,
    method.tau = method,
    random = random_effects,
    method.random.ci = "classic",
    ...
  )
  df_meta <- summary(meta)
  df_meta <- df_meta$random
  df_meta <- vec2df(
    study_label = study_label_meta,
    estimate = df_meta$TE,
    lower = df_meta$lower,
    upper = df_meta$upper,
    .col_names = c(study_label, ".ve_log_ratio_estimate", ".ve_log_ratio_lower", ".ve_log_ratio_upper")
  )
  df_meta$.ve_ratio_estimate <- exp(df_meta$.ve_log_ratio_estimate)
  df_meta$.ve_ratio_lower <- exp(df_meta$.ve_log_ratio_lower)
  df_meta$.ve_ratio_upper <- exp(df_meta$.ve_log_ratio_upper)
  df_meta$.ve_estimate <- (1 - df_meta$.ve_ratio_estimate)*100
  df_meta$.ve_lower <- (1 - df_meta$.ve_ratio_lower)*100
  df_meta$.ve_upper <- (1 - df_meta$.ve_ratio_upper)*100
  list(
    df = df_meta,
    meta = meta
  )
}

#' Run complete meta-analysis pipeline for OR or RR
#'
#' @noRd
meta_analyze_ratio <- function(
    df,
    estimate = "adjusted_estimate",
    lower = "adjusted_lower_ci",
    upper = "adjusted_upper_ci",
    grouping_var = NULL,
    study_label = "study_label",
    study_label_meta = "Meta-analysis",
    effect_measure = "OR",
    method = "DL",
    random_effects = TRUE,
    incl_cols = NULL,
    transform_to_log_odds = log,
    backtransform_from_log_odds = exp,
    force_lower_upper = TRUE,
    as_df = FALSE,
    ...) {
  df$is_meta <- df$id_meta <- NULL
  cols <- c(estimate, lower, upper)
  idx <- apply(df[cols], 1, function(x) all(is.finite(x)))
  #df <- df[stats::complete.cases(df[cols]), , drop = FALSE]
  if (!any(idx)) return(NULL)
  df <- df[idx, , drop = FALSE]
  df_names <- names(df)
  idx <- vapply(df, is.numeric, logical(1), USE.NAMES = FALSE)
  idx <- match(cols, df_names[idx], nomatch = 0L) == 0L
  if (any(idx)) {
    stop(sprintf("In 'meta_analyze_ratio', the following inputs to %s do not refer to numeric columns in 'df': %s", paste(shQuote(c("estimate", "lower", "upper")[idx]), collapse = "/"), paste(cols[idx], collapse = ", ")))
  }
  incl_cols <- setdiff(intersect(incl_cols, df_names), c(cols, study_label))
  estimate_original <- .subset2(df, estimate)
  lower_original <- .subset2(df, lower)
  upper_original <- .subset2(df, upper)
  est <- transform_to_log_odds(estimate_original)
  lo <- transform_to_log_odds(lower_original)
  hi <- transform_to_log_odds(upper_original)
  idx <- is.finite(est) & is.finite(lo) & is.finite(hi)
  if (!all(idx)) {
    if (!any(idx)) return(NULL)
    est <- est[idx]
    lo <- lo[idx]
    hi <- hi[idx]
    df <- df[idx, , drop = FALSE]
  }
  # Swap lower and upper if lower > upper after transformation
  if (force_lower_upper && any(idx <- lo > hi)) {
    z <- hi
    hi[idx] <- lo[idx]
    lo[idx] <- z[idx]
  }
  row_idx <- seq_along(est)
  if (is.null(grouping_var)) {
    row_idx <- list(a = row_idx)
  } else {
    incl_cols <- unique(c(grouping_var, incl_cols))
    m <- df
    for (i in grouping_var) {
      m[[i]] <- as.character(m[[i]])
      m[[i]][is.na(m[[i]])] <- "MISSING___"
    }
    row_idx <- split(row_idx, f = as.list(m[grouping_var]))
  }
  #idx <- lengths(row_idx, use.names = FALSE) > 1L
  #row_idx <- row_idx[idx]
  add_cols <- length(incl_cols) > 0L
  metagen_args <- list(
    sm = effect_measure,
    method.tau = method,
    random = random_effects,
    method.random.ci = "classic",
    ...
  )
  df$is_meta <- FALSE
  run_meta <- function(i) {
    row_id <- row_idx[[i]]
    x <- df[row_id, , drop = FALSE]
    x$id_meta <- i
    metagen_args$TE <- est[row_id]
    metagen_args$lower <- lo[row_id]
    metagen_args$upper <- hi[row_id]
    meta <- tryElse(do.call(meta::metagen, metagen_args))
    if (is.null(meta)) {
      return(list(plot_data = x, grouping_var = grouping_var))
    }
    df_meta <- summary(meta)
    df_meta <- df_meta$random
    df_meta <- vec2df(estimate = df_meta$TE, lower = df_meta$lower, upper = df_meta$upper, .col_names = cols)
    for (j in cols) {
      df_meta[[j]] <- backtransform_from_log_odds(.subset2(df_meta, j))
    }
    if (add_cols) {
      z <- x[, incl_cols, drop = FALSE]
      idx <- vapply(z, function(y) length(unique(y)) == 1L, logical(1), USE.NAMES = FALSE)
      if (any(idx)) {
        df_meta <- cbind(z[1L, idx], df_meta)
      }
    }
    df_meta$is_meta <- TRUE
    df_meta$id_meta <- i
    meta$summary_table <- df_meta
    meta$plot_data <- tryCatch(dplyr::bind_rows(x, df_meta), error = function(e) NULL)
    meta$grouping_var <- grouping_var
    meta
  }
  out <- lapply(seq_along(row_idx), run_meta)
  if (as_df) {
    out <- lapply(out, `[[`, "summary_table")
    out <- dplyr::bind_rows(out)
    if (!is.null(study_label)) {
      if (length(study_label) != 1L || match(study_label, names(out), nomatch = 0L) != 0L) {
        study_label <- "study_label"
      }
      out[[study_label]] <- study_label_meta
    }
    out <- out[unique(c(study_label, setdiff(names(out), cols), cols))]
  } else if (length(out) == 1L) {
    out <- out[[1L]]
  }
  out
}

#' Run meta-analysis for VE input
#'
#' Only use when VE estimated using (1 - OR)x100 or (1 - RR)x100
#' @noRd
meta_analyze_ve <- function(
    df,
    estimate = "adjusted_estimate",
    lower = "adjusted_lower_ci",
    upper = "adjusted_upper_ci",
    grouping_var = NULL,
    study_label = "study_label",
    study_label_meta = "Meta-analysis",
    effect_measure = "OR",
    method = "DL",
    random_effects = TRUE,
    incl_cols = NULL,
    as_df = FALSE,
    ...) {
  meta_analyze_ratio(
    df,
    estimate = estimate,
    lower = lower,
    upper = upper,
    grouping_var = grouping_var,
    study_label = study_label,
    study_label_meta = study_label_meta,
    effect_measure = effect_measure,
    method = method,
    random_effects = random_effects,
    incl_cols = incl_cols,
    transform_to_log_odds = function(x) log(1 - x/100),
    backtransform_from_log_odds = function(x) (1 - exp(x))*100,
    force_lower_upper = TRUE,
    as_df = as_df,
    ...
  )
}

#' Extract data frame from meta-analysis results
#'
#' @noRd
meta2df <- function(x, type = "plot_data", ...) {
  if (length(x) == 0L) return(NULL)
  x <- if (inherits(x, "meta")) x[[type]] else tryElse(dplyr::bind_rows(lapply(x, `[[`, type)))
  if (is.null(x) || nrow(x) == 0L) return(NULL)
  if (...length() != 0L && all(nzchar(names(new_cols <- list(...))))) {
    n_rows <- lengths(new_cols, use.names = FALSE)
    new_cols <- new_cols[n_rows == 1L | n_rows == nrow(x)]
    if (length(new_cols) != 0L) {
      x <- cbind(new_cols, x)
    }
  }
  x
}
